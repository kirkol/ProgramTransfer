#include "FATFileSystem.h"
#include "SDBlockDevice.h"
#include <cctype>
#include <vector>

// debbuging (diody na sterowniku)
DigitalOut led1(LED1);
DigitalOut led2(LED2);
DigitalOut led3(LED3);
DigitalOut led4(LED4);

// debbuging (diody zewnetrzne)
DigitalOut ledCzerwona(p26);
DigitalOut ledZolta(p25);

// Serial dla PC
Serial pc(USBTX, USBRX);

// dla RS232
Serial uart(p13, p14);
DigitalOut RTSwyjscieRS(p22);
DigitalIn CTSwejscieRS(p17);

// internety
EthernetInterface eth;
Ethernet ether;
TCPSocket sock;

// karta SD
SDBlockDevice sd(p5,p6,p7,p9);
FATFileSystem fs("sd", &sd);

// mruga diodami i wyswietla, ze udalo sie nawiazac polaczenie z Socketem
void SocketOK(){
    
    pc.printf("\n SOCKET OPENED \n");
    led1 = 1; wait(0.2); led1 = 0; wait(0.2); led1 = 1; wait(0.2); led1 = 0; wait(0.2); led1 = 1; wait(0.2); led1 = 0;
}

// mruga diodami i wyswietla, ze NIE udalo sie nawiazac polaczenia z Socketem
void SocketFAIL(){

    pc.printf("\n SOCKET IS UNAVAILABLE \n");
    led2 = 1; ledCzerwona = 1; ledZolta = 1; wait(0.5); led2 = 0; ledCzerwona = 0; ledZolta = 0; wait(0.5); 
    led2 = 1; ledCzerwona = 1; ledZolta = 1; wait(0.5); led2 = 0; ledCzerwona = 0; ledZolta = 0; wait(0.5); 
    led2 = 1; ledCzerwona = 1; ledZolta = 1; wait(0.5); led2 = 0; ledCzerwona = 0; ledZolta = 0;
}

int CheckMbedIsStillAlive(int *i){
    
    if(*i%30000 == 0){
        led1 = 1; 
    }else{
        led1 = 0;
    }
    if(*i >= 90000){
        *i = 0;
    }
    return *i;
}

// jesli nie ma Internetu (np. przewod jest odlaczony), to ta funkcja bedzie sie wywolywac caly czas w petli
void ReconnectIfNoNet(){
    
    pc.printf("\n INTERNET IS UNAVAILABLE, BUT I'M TRYING TO CONNECT ANYWAY... \n");
    led4 = 1; ledCzerwona = 1; ledZolta = 1;
    eth.connect(); 
    wait(1);
    led4 = 0; ledCzerwona = 0; ledZolta = 0;
}

// usuwa z pliku nagolwki z Servera, oraz nadmiarowa tresc po M30
void CleanTheMessInFile(string pathSentToMachineSD, string programName, string extension){
    
    FILE *fileOld;
    FILE *fileNew;
    char c = 'a';
    
    fileOld = fopen((pathSentToMachineSD + programName + "withMess" +  extension).c_str(), "r");
    if(fileOld == NULL) {
        NVIC_SystemReset();
        error("Could not open file for write\n");
    }
    
    fileNew = fopen((pathSentToMachineSD + programName +  extension).c_str(), "w");
    if(fileNew == NULL) {
        NVIC_SystemReset();
        error("Could not open file for write\n");
    }
    
    fclose(fileOld);
    fclose(fileNew);
    
}

//wysyla program na serwer przez HTTP
void Send_From_SD_to_Server_HTTP (string ProgramName, char *server_ip, int port, string path, string extension){
    
    FILE *file;
    string line = "";
    string request = "";
    char array[500] = "";
    char c = 'a';
    int conn = -1;
    
    //usun plik z Servera, jesli taki juz istnieje (i jest polaczenie z Serverem)
    pc.printf("DELETE IF EXIST \n");
    pc.printf("\n I'M OPENING THE SOCKET! \n");
    sock.open(&eth);
    conn = sock.connect(server_ip, port);
    if(conn == 0){
        SocketOK();
        request = "GET /delete_if_exist.php?program_name=" + ProgramName + "&extension=" + extension + " HTTP/1.0\r\n\r\n";
        strcpy(array, request.c_str());
        sock.send(array, sizeof(array));  
    }else{
        SocketFAIL();
    }
    sock.close();
    pc.printf("\n OK, I CLOSED IT, CYA \n"); 
    
    // otworz plik na SD
    pc.printf("OPEN A FILE \n");
    file = fopen((path + ProgramName + extension).c_str(), "r");
    if(file == NULL) {
        NVIC_SystemReset();
        error("Could not open file for write\n");
    }
    
    while(!feof(file)){ // pobiera znaki az do konca pliku (EOF)
        c = fgetc(file);
    
        if(c != 13 && c != 10){
            if(c == 32){ // zamienia spacje na ~ (wymagane do zapytan PHP, w ktorych nie moze pojawic sie znak spacji, znak '13' ani znak '10' - zamieniane i dodawane sa z powrotem po stronie Servera)
                c = '~';
            }
            line += c;
        }

        if(c == 13 || c ==10){
            pc.printf("%s", line);
            pc.printf("\n");
            request = "GET /send_file_to_server_HTTP.php?program_name=" + ProgramName + "&extension=" + extension + "&line=" + line + " HTTP/1.0\r\n\r\n";
            strcpy(array, request.c_str());
            pc.printf("%s", array);
            pc.printf("\n");
            
            // otworz polaczenie z Serverem
            pc.printf("\n I'M OPENING THE SOCKET! \n");
            sock.open(&eth);
            conn = sock.connect(server_ip, port);
            if(conn == 0){
                SocketOK();
            }else{
                SocketFAIL();
            }
            pc.printf("SOCK IS: %d\n", conn);
            
            sock.send(array, sizeof(array)); // wysyla linie z pliku
            
            // zamknij polaczenie z Serverem
            sock.close();
            pc.printf("\n OK, I CLOSED IT, CYA \n"); 
            
            line = "";
        }
    }
    
    if(conn==0){
        //jesli jest polaczenie z Serverem, to usun tez plik z SD
        remove((path + ProgramName + extension).c_str());        
    }
    
    fclose(file);
    pc.printf("FILE CLOSED");
    
}

// szuka nazwy w zapisanym pliku (szuka pierwszych 4 cyfr w programie i traktuje je jako jego nazwe)
string RenameFile(string path, string extension){
    
    char c = 'a';
    string programName = "";
    FILE *file;
    file = fopen((path + "NazwaPliku" + extension).c_str(), "r");
    if(file == NULL) {
        NVIC_SystemReset();
        error("Could not open file for write\n");
    }
    while(!feof(file)){
        c = fgetc(file);
        if(isdigit(c)){
            programName = programName + c;
            if(programName.length() == 4){
                fclose(file);
                break;
            }
        }
    }
    
    rename((path + "NazwaPliku" + extension).c_str(), (path + programName + "WithTildas" + extension).c_str());
    
    return programName;
    
}

// dla programow Siemensowych - usuwa znaki tyldy na poczatku i koncu programu
void RemoveTildas(string programName, string path, string extension){

    FILE *fileOld;
    FILE *fileNew;
    char c = 'a';
    
    fileOld = fopen((path + programName + "WithTildas" + extension).c_str(), "r");
    if(fileOld == NULL) {
        NVIC_SystemReset();
        error("Could not open file for write\n");
    }
  
    fileNew = fopen((path + programName + extension).c_str(), "w");
    if(fileNew == NULL) {
        NVIC_SystemReset();
        error("Could not open file for write\n");
    }
    
    while(!feof(fileOld)){
        c = fgetc(fileOld);
        if(c != '~'){
            fputc(c, fileNew);
        }    
    }
    fclose(fileNew);
    fclose(fileOld);
    
    remove((path + programName + "WithTildas" + extension).c_str());

}

// wysyla zapytanie o program do Servera (gdy operator uzyl programu 5002)
void AskServerForProgram(string programName, char *server_ip, int port, string extension, string pathSentToMachineSD, string pathArchive){
    
    int conn = -1;
    char array[200] = "";
    char arrayNew[1000] = "";
    char arrayPrev[1000] = "";
    char c = 'a';
    string request = "";
    FILE *file;
    FILE *fileOnSD;
    FILE *fileArchive;
    
    pc.printf("NR PROGRAMU: %s \n",programName);
    
    //otworz polaczenie z Serverem
    sock.open(&eth);
    conn = sock.connect(server_ip, port);
    if(conn == 0){
        SocketOK();
        //usun poprzedni plik z programem z karty SD, jesli istnieje (w sendToMachine zawsze zostaje najaktualniejszy)
        remove((pathSentToMachineSD + programName + extension).c_str());
        request = "GET /ProgramsExchange/receivedFromMachine/" + programName + extension + " HTTP/1.0\r\n\r\n";
        pc.printf("%s", request);
        strcpy(array, request.c_str());
        sock.send(array, sizeof(array));  
        
        //przechwyc odpowiedz z Servera
        while(1){
            file = fopen((pathSentToMachineSD + programName + "withMess" +  extension).c_str(), "a");
            if(file == NULL) {
                NVIC_SystemReset();
                error("Could not open file for write\n");
            }
            sock.recv(arrayNew, sizeof arrayNew);
            pc.printf("\n ARRAY - %s \n", arrayNew);
            
            fprintf(file, "%s", arrayNew);
            
            if(memcmp(arrayPrev, arrayNew, sizeof(arrayNew))==0){
                pc.printf("PRZERWANO");
                break;
            }
            
            memcpy(arrayPrev, arrayNew, sizeof(arrayNew));
            
        }
        fclose(file);
        pc.printf("\n PLIK ZAPISANO NA SERVERZE\n");
        
        //usuwa z pliku nagolwki z Servera, oraz nadmiarowa tresc po M30
        CleanTheMessInFile(pathSentToMachineSD, programName, extension);
        
        //kopiuj plik do Archive
        fileOnSD = fopen((pathSentToMachineSD + programName + extension).c_str(), "r");
        if(fileOnSD == NULL) {
            NVIC_SystemReset();
            error("Could not open file for write\n");
        }
        fileArchive = fopen((pathArchive + programName + extension).c_str(), "w");
        if(file == NULL) {
            NVIC_SystemReset();
            error("Could not open file for write\n");
        }
        while(!feof(fileOnSD)){
            c = fgetc(fileOnSD);
            fputc(c, fileArchive);
        }
        pc.printf("\n PLIK SKOPIOWANO DO ARCHIWUM\n");
        fclose(file);
        fclose(fileArchive);
        
    }else{
        SocketFAIL();
    }
    sock.close();
    pc.printf("\n OK, I CLOSED IT, CYA \n"); 
}
